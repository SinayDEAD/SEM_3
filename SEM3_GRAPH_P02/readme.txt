Автор: 
 Ибрагимова София 208

Вариант: 
 3.Граф

Основные функции: 
 Создание
 Добавление вершину
 Добавление ребра
 Удаление ребра
 Удаление вершины
 Уничтожение графа

Дополнительные функции: 
 Печать в глубь или печать в ширину
 Печать списка связи
 Меню

В архиве:
 Тут есть 2 папки main и main2, первая это дефолтный тест,
 вторая это режим меню.

Особенности:
 В первом режиме в main лежит автотест, проверяющий все 
 функции кроме меню и на выбор был выбрана печать в 
 ширину. Во втором режиме main2, пользователю предлагается,
 сначала создать граф с неким кол-вом вершин > 0, и 
 далее в меню пользователь, может выбрать режимы. 
 Из особенностей, пользователю доступна за раз только
 одна печать в ширину или в длину, просьба также не вводить
 несуществующие вершины для функций. В конце пользователь
 Выбирает 9 режим и граф удаляется автоматически. Граф 
 ненаправленный, возможны пути в сами себя. При вводе 0 
 вершин программа exit(). Память хранится в виде списка
 смежности. 

Все функции:
struct Node* CreateNode(int v); //создаём

struct Node{
   int vertex;             //вершина №
   int nv;                 //счёт с кем
   struct Node *next;      //родственник
};

struct Graph{
   int *visited;           //для ширины или глубины
   struct Node **adjlists; //структура для хранения памяти
   int numvertices;        //кол-во вершин графа
};

struct Graph *CreateGraph(int v); //создаём граф

void AddEdge(struct Graph *graph, int a, int b); // добавление ребра в уже существующий граф

void PrintGraph(struct Graph *graph); //печать всего графа со писком смежности 

void DeleteGraph(struct Graph **graph); // уничтожаем весь граф

void RemoveEdge(struct Graph *graph, int a, int b); // убераем ребро существующее

void RemoveVertex(struct Graph *graph, int v); // удаляем вершину существующую

void AddVertex(struct Graph *graph); // добавляем вершину в существующий граф 

void DFS(struct Graph*, int v); //обход в в глубину с печатью 


{
struct Turn {            // структура для обхода в ширину
    int it[SIZE];
    int f;
    int r;
};

struct Turn *CreateQueue(void); //создание

void Enq(struct Turn *q, int); //для переполнения        || всё это для BFS

int Deq(struct Turn *q);  //для печати

int Empty(struct Turn *q); //проверка на пустоту

void PrintQueue(struct Turn *q); //печать обхода в очереди
}


void BFS(struct Graph *graph, int s); //обход в ширину с печатью

void PrintMenu(void); // Меню для  main2 и пользовательского режима

int GetVariant(int c); //для взятия варианта пользовательского режима 
 